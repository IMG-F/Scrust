// defines the costume's name, file path, and rotation center
costume "costume1" "assets/sprite.svg" 32 32;


private var result = 0;
private var bounce_val = 0;
private var t = 0;
private var v = 0;
private var mode = "";
private var c1 = 0;
private var c2 = 0;
private var c3 = 0;
private var n1 = 0;
private var d1 = 0;
private var x2 = 0;
private var start_time = 0;
private var current_time = 0;


#[warp]
proc calculate_animation(type: string, process_percent: number, from: number, to: number, ease_in: boolean, ease_out: boolean){
    if from == to {
        result = from;
    } else {
        t = process_percent / 100;
        if t > 1 { t = 1; }
        if t < 0 { t = 0; }

        v = t;
        
        // Determine ease mode
        mode = "Linear";
        if ease_in && ease_out {
            mode = "InOut";
        } else {
            if ease_in {
                mode = "In";
            } else {
                if ease_out {
                    mode = "Out";
                }
            }
        }
        
        match type {
            "Linear" => {
                v = t;
            }
            "Sine" => {
                match mode {
                    "In" => { v = 1 - cos(t * 90); }
                    "Out" => { v = sin(t * 90); }
                    "InOut" => { v = -(cos(t * 180) - 1) / 2; }
                }
            }
            "Quad" => {
                match mode {
                    "In" => { v = t * t; }
                    "Out" => { v = 1 - (1 - t) * (1 - t); }
                    "InOut" => {
                        if t < 0.5 {
                            v = 2 * t * t;
                        } else {
                            v = 1 - (-2 * t + 2) * (-2 * t + 2) / 2;
                        }
                    }
                }
            }
            "Cubic" => {
                match mode {
                    "In" => { v = t * t * t; }
                    "Out" => { v = 1 - (1 - t) * (1 - t) * (1 - t); }
                    "InOut" => {
                        if t < 0.5 {
                            v = 4 * t * t * t;
                        } else {
                            v = 1 - (-2 * t + 2) * (-2 * t + 2) * (-2 * t + 2) / 2;
                        }
                    }
                }
            }
            "Quart" => {
                match mode {
                    "In" => { v = t * t * t * t; }
                    "Out" => { v = 1 - (1 - t) * (1 - t) * (1 - t) * (1 - t); }
                    "InOut" => {
                        if t < 0.5 {
                            v = 8 * t * t * t * t;
                        } else {
                            v = 1 - (-2 * t + 2) * (-2 * t + 2) * (-2 * t + 2) * (-2 * t + 2) / 2;
                        }
                    }
                }
            }
            "Quint" => {
                match mode {
                    "In" => { v = t * t * t * t * t; }
                    "Out" => { v = 1 - (1 - t) * (1 - t) * (1 - t) * (1 - t) * (1 - t); }
                    "InOut" => {
                        if t < 0.5 {
                            v = 16 * t * t * t * t * t;
                        } else {
                            v = 1 - (-2 * t + 2) * (-2 * t + 2) * (-2 * t + 2) * (-2 * t + 2) * (-2 * t + 2) / 2;
                        }
                    }
                }
            }
            "Circ" => {
                match mode {
                    "In" => { v = 1 - sqrt(1 - t * t); }
                    "Out" => { v = sqrt(1 - (t - 1) * (t - 1)); }
                    "InOut" => {
                        if t < 0.5 {
                            v = (1 - sqrt(1 - (2 * t) * (2 * t))) / 2;
                        } else {
                            v = (sqrt(1 - (-2 * t + 2) * (-2 * t + 2)) + 1) / 2;
                        }
                    }
                }
            }
            "Back" => {
                c1 = 1.70158;
                c3 = c1 + 1;
                match mode {
                    "In" => { v = c3 * t * t * t - c1 * t * t; }
                    "Out" => { v = 1 + c3 * (t - 1) * (t - 1) * (t - 1) + c1 * (t - 1) * (t - 1); }
                    "InOut" => {
                        c2 = c1 * 1.525;
                        if t < 0.5 {
                            v = ((2 * t) * (2 * t) * ((c2 + 1) * 2 * t - c2)) / 2;
                        } else {
                            v = ((2 * t - 2) * (2 * t - 2) * ((c2 + 1) * (2 * t - 2) + c2) + 2) / 2;
                        }
                    }
                }
            }
            "Bounce" => {
                match mode {
                    "Out" => {
                        calculate_bounce_out(t);
                        v = bounce_val;
                    }
                    "In" => {
                        calculate_bounce_out(1 - t);
                        v = 1 - bounce_val;
                    }
                    "InOut" => {
                        if t < 0.5 {
                            calculate_bounce_out(1 - 2 * t);
                            v = (1 - bounce_val) / 2;
                        } else {
                            calculate_bounce_out(2 * t - 1);
                            v = (1 + bounce_val) / 2;
                        }
                    }
                }
            }
        }
        
        result = from + (to - from) * v;
    }
}

#[warp]
proc calculate_bounce_out(x: number) {
    n1 = 7.5625;
    d1 = 2.75;
    
    if x < 1 / d1 {
        bounce_val = n1 * x * x;
    } else {
        if x < 2 / d1 {
            x2 = x - 1.5 / d1;
            bounce_val = n1 * x2 * x2 + 0.75;
        } else {
            if x < 2.5 / d1 {
                x2 = x - 2.25 / d1;
                bounce_val = n1 * x2 * x2 + 0.9375;
            } else {
                x2 = x - 2.625 / d1;
                bounce_val = n1 * x2 * x2 + 0.984375;
            }
        }
    }
}

#[on_flag_clicked]
fn opener_change_size() {
    set_size_to(0);
    show();
    
    reset_timer();
    start_time = timer();
    
    until timer() > (start_time + 1) {
        current_time = timer();
        calculate_animation("Back", (current_time - start_time) * 100, 0, 200, false, true);
        set_size_to(result);
    }
    
    set_size_to(200);
}
